# セルフバランシングバイク - 角度計算とモーター制御の技術レポート

## 1. 角度計算システム

### 1.1 概要
MPU6050センサーから加速度計とジャイロのデータを取得し、補完フィルタ（Complementary Filter）を使用してロボットの傾き角度を計算します。

### 1.2 センサーデータの取得

#### MPU6050の設定
```73:105:01.Arduino Code and Library/functions.ino
void angle_calc() {

  Wire.beginTransmission(MPU6050);                // 6050スレーブへのデータ送信開始
  Wire.write(ACCEL_YOUT_H);                       // 加速度Y軸の上位8ビット
  Wire.endTransmission(false);                    // 再開信号を送信し、I2C接続を維持
  Wire.requestFrom(MPU6050, 2, true);             // データ要求信号を送信
  AcY = Wire.read() << 8 | Wire.read();           // 読み取ったY軸の生加速度データ
  
  Wire.beginTransmission(MPU6050);
  Wire.write(ACCEL_ZOUT_H);                  
  Wire.endTransmission(false);
  Wire.requestFrom(MPU6050, 2, true);  
  AcZ = Wire.read() << 8 | Wire.read();           // 読み取ったZ軸の生加速度データ

  Wire.beginTransmission(MPU6050);
  Wire.write(GYRO_XOUT_H);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU6050, 2, true); 
  GyX = Wire.read() << 8 | Wire.read();           // 読み取ったX軸の生ジャイロデータ

  AcYc = AcY - offsets.AcY;                       // Y軸と保存されたキャリブレーション値の差分                       
  AcZc = AcZ - offsets.AcZ;                       // Z軸と保存されたキャリブレーション値の差分
  GyX = GyX - GyX_offset;

  robot_angle += GyX * loop_time / 1000 /131.072;
  Acc_angle = -atan2(AcYc, -AcZc) * 57.2958;   
  robot_angle = robot_angle * Gyro_amount + Acc_angle * (1.0 - Gyro_amount);  

  if (abs(robot_angle) > 10) vertical = false;
  if (abs(robot_angle) < 0.3) vertical = true;
  
}
```

#### 取得データ
- **加速度計**: Y軸（AcY）、Z軸（AcZ）の生データ
- **ジャイロ**: X軸（GyX）の生データ

### 1.2.1 MPU6050センサーの概要

#### MPU6050とは
MPU6050は、InvenSense（現TDK）が開発した6軸慣性測定ユニット（IMU）です。1つのチップに3軸加速度計と3軸ジャイロスコープを統合しており、I2C通信でデータを取得できます。

#### 主な仕様
- **通信方式**: I2C（Inter-Integrated Circuit）
- **I2Cアドレス**: 0x68（AD0ピンがLOWの場合）
- **加速度計**: ±2g, ±4g, ±8g, ±16gの範囲で設定可能（本システムでは±2g）
- **ジャイロスコープ**: ±250°/s, ±500°/s, ±1000°/s, ±2000°/sの範囲で設定可能（本システムでは±500°/s）
- **動作電圧**: 3.3V～5V
- **サンプリングレート**: 最大1kHz

#### 本システムでの設定
```24:25:01.Arduino Code and Library/functions.ino
#define accSens 0             // 0 = 2g, 1 = 4g, 2 = 8g, 3 = 16g
#define gyroSens 1            // 0 = 250rad/s, 1 = 500rad/s, 2 1000rad/s, 3 = 2000rad/s
```

- **加速度計感度**: ±2g（`accSens = 0`）
- **ジャイロ感度**: ±500°/s（`gyroSens = 1`）
- **LSB/度/秒**: 131.072（500°/sレンジ時）

### 1.2.2 ジャイロスコープ（Gyroscope）の詳細

#### 動作原理
ジャイロスコープは、角速度（回転速度）を検出するセンサーです。本システムで使用されているMPU6050のジャイロは、MEMS（Micro Electro Mechanical Systems）技術を使用した振動式ジャイロです。

**動作メカニズム**:
1. 内部の振動子が一定の周波数で振動している
2. 回転が発生すると、コリオリ力が作用する
3. この力によって振動子の振動方向が変化する
4. 振動方向の変化量から角速度を検出する

#### ジャイロの特性

**長所**:
- **短期的な精度が高い**: 瞬間的な角度変化を正確に検出できる
- **応答速度が速い**: 高速な動きにも追従できる
- **振動に強い**: 外部の振動の影響を受けにくい
- **動的動作に適している**: 移動中や回転中の角度検出に優れている

**短所**:
- **ドリフトが発生する**: 時間の経過とともに誤差が蓄積される（積分誤差）
- **温度依存性**: 温度変化によってオフセットが変動する
- **長期精度が低い**: 長時間の積分により誤差が大きくなる
- **初期オフセット**: 起動時にオフセット補正が必要

#### 本システムでの使用
- **検出軸**: X軸のみ（前後方向の回転）
- **用途**: ロボットの前後方向の傾き角速度を検出
- **データ処理**: 角速度を積分して角度を算出
- **補正**: 起動時に1024サンプルでオフセットを自動補正

```36:36:01.Arduino Code and Library/functions.ino
  robot_angle += GyX * loop_time / 1000 /131.072;
```

この式で、角速度（GyX）を時間で積分して角度変化量を計算しています。

### 1.2.3 加速度計（Accelerometer）の詳細

#### 動作原理
加速度計は、重力加速度を含む加速度を検出するセンサーです。MPU6050の加速度計は、MEMS技術を使用した静電容量式加速度計です。

**動作メカニズム**:
1. 内部の可動電極（質量）が固定電極の間に配置されている
2. 加速度が加わると、慣性力によって可動電極が変位する
3. 電極間の静電容量の変化を検出する
4. 静電容量の変化量から加速度を算出する

#### 加速度計の特性

**長所**:
- **長期的な精度が高い**: 重力加速度を基準にしているため、ドリフトが少ない
- **絶対角度が得られる**: 重力方向を基準にした角度を直接計算できる
- **温度安定性**: 温度変化による影響が比較的少ない
- **静止状態に適している**: 動きが少ない状態での角度検出に優れている

**短所**:
- **振動に弱い**: 外部の振動や加速度の影響を直接受ける
- **動的動作に不向き**: 移動中の加速度と重力加速度を区別できない
- **応答速度が遅い**: 高速な動きには追従しにくい
- **ノイズが多い**: 高周波ノイズの影響を受けやすい

#### 本システムでの使用
- **検出軸**: Y軸とZ軸（左右・上下方向の加速度）
- **用途**: 重力加速度からロボットの傾き角度を直接計算
- **データ処理**: `atan2()`関数でY-Z平面の角度を算出

```37:37:01.Arduino Code and Library/functions.ino
  Acc_angle = -atan2(AcYc, -AcZc) * 57.2958;
```

この式で、Y軸とZ軸の加速度から重力方向に対する角度を直接計算しています。

#### 重力加速度の利用
加速度計は、重力加速度（約9.8 m/s²）を検出することで、重力方向に対する傾き角度を計算できます：

- **垂直状態**: Z軸に重力がかかる（AcZ ≈ 16384 LSB、±2gレンジ時）
- **傾斜状態**: Y軸とZ軸に重力が分散される
- **角度計算**: `atan2(AcY, AcZ)`で重力方向に対する角度を算出

### 1.3 キャリブレーション処理

#### 初期化時のオフセット補正
```112:130:01.Arduino Code and Library/functions.ino
void angle_setup() {
  Wire.begin();                                   // I2Cマスターとして初期化
  delay(100);                                     // 遅延
  writeTo(MPU6050, PWR_MGMT_1, 0);                // MPU6050電源レジスタの初期化
  writeTo(MPU6050, ACCEL_CONFIG, accSens << 3);   // 加速度計の出力スケールを指定
  writeTo(MPU6050, GYRO_CONFIG, gyroSens << 3);   // ジャイロの出力スケールを指定
  delay(100);                                     // 遅延

  for (int i = 0; i < 1024; i++) {
    angle_calc();
    GyX_offset_sum += GyX;
    delay(3);
  }

  GyX_offset = GyX_offset_sum >> 10;
  beep();
  beep();
  Serial.print("GyX offset: ");  Serial.println(GyX_offset);
}
```

- **ジャイロオフセット**: 1024サンプルを平均化（約3秒間）
- **加速度計オフセット**: EEPROMに保存されたキャリブレーション値を使用

### 1.4 補完フィルタによる角度計算

#### アルゴリズムの実装
```97:99:01.Arduino Code and Library/functions.ino
  robot_angle += GyX * loop_time / 1000 /131.072;
  Acc_angle = -atan2(AcYc, -AcZc) * 57.2958;   
  robot_angle = robot_angle * Gyro_amount + Acc_angle * (1.0 - Gyro_amount);
```

#### 計算式の詳細

1. **ジャイロによる角度積分**
   ```
   robot_angle += GyX × (loop_time / 1000) / 131.072
   ```
   - `GyX`: X軸ジャイロの生データ（LSB単位）
   - `loop_time`: 10ms（制御周期）
   - `131.072`: 500°/sレンジ時のLSB/度/秒（gyroSens=1）

2. **加速度計による角度計算**
   ```
   Acc_angle = -atan2(AcYc, -AcZc) × 57.2958
   ```
   - `atan2`: Y-Z平面での角度を計算
   - `57.2958`: ラジアンから度への変換係数（180/π）

3. **補完フィルタによる統合**
   ```
   robot_angle = robot_angle × Gyro_amount + Acc_angle × (1.0 - Gyro_amount)
   ```
   - `Gyro_amount = 0.896`: ジャイロの重み（約90%）
   - 加速度計の重み: 約10%

#### 補完フィルタの特性

補完フィルタは、ジャイロと加速度計の**相反する特性を補完し合う**ことで、安定した角度を算出します。

**ジャイロの特性**:
- ✅ **短期的に正確**: 瞬間的な角度変化を正確に検出できる
- ✅ **応答速度が速い**: 高速な動きにも追従できる
- ✅ **振動に強い**: 外部の振動の影響を受けにくい
- ❌ **ドリフトが発生**: 時間の経過とともに誤差が蓄積される（積分誤差）
- ❌ **長期精度が低い**: 長時間の積分により誤差が大きくなる

**加速度計の特性**:
- ✅ **長期的に正確**: 重力加速度を基準にしているため、ドリフトが少ない
- ✅ **絶対角度が得られる**: 重力方向を基準にした角度を直接計算できる
- ✅ **温度安定性**: 温度変化による影響が比較的少ない
- ❌ **振動に弱い**: 外部の振動や加速度の影響を直接受ける
- ❌ **動的動作に不向き**: 移動中の加速度と重力加速度を区別できない
- ❌ **応答速度が遅い**: 高速な動きには追従しにくい

**補完フィルタによる統合**:
- **ジャイロの重み**: 90%（`Gyro_amount = 0.896`）
  - 短期的な動きや高速な変化を主にジャイロで検出
- **加速度計の重み**: 10%（`1.0 - Gyro_amount = 0.104`）
  - 長期的なドリフトを加速度計で補正
- **結果**: 両者の長所を活かし、短所を補完した安定した角度が得られる

**補完フィルタの動作**:
```
robot_angle = robot_angle × 0.896 + Acc_angle × 0.104
```

この式により：
- ジャイロの高速応答性を活かしつつ
- 加速度計で長期的なドリフトを補正
- 振動の影響を最小限に抑える

**本システムでの重み設定の理由**:
- セルフバランシングバイクは**高速な動き**が重要
- ジャイロの重みを高くすることで、**応答性を優先**
- 加速度計の重みを低くすることで、**振動ノイズの影響を軽減**
- 10%の加速度計の重みで、**長期的なドリフトを抑制**

### 1.5 垂直判定

```101:102:01.Arduino Code and Library/functions.ino
  if (abs(robot_angle) > 10) vertical = false;
  if (abs(robot_angle) < 0.3) vertical = true;
```

- **垂直範囲**: ±0.3度以内で`vertical = true`
- **倒立判定**: ±10度を超えると`vertical = false`

## 2. モーター制御システム

### 2.1 概要
PID制御アルゴリズムを使用してモーターを制御し、バランスを維持します。

### 2.2 PID制御の実装

#### 制御ループ
```136:155:01.Arduino Code and Library/self_balancing_bike.ino
  if (currentT - previousT_1 >= loop_time) {
    readControlParameters();  
    angle_calc();

    motor_speed = -enc_count;
    enc_count = 0;

    if (vertical && calibrated && !calibrating) {
      digitalWrite(BRAKE, HIGH);
      gyroX = GyX / 131.0; // 度/秒に変換

      gyroXfilt = alpha * gyroX + (1 - alpha) * gyroXfilt;

      motor_pos += motor_speed;
      motor_pos = constrain(motor_pos, -110, 110);
      
      int pwm = constrain(K1 * robot_angle + K2 * gyroXfilt + K3 * motor_speed + K4 * motor_pos, -255, 255); 
      Motor1_control(-pwm);
```

#### PIDパラメータ
```31:34:01.Arduino Code and Library/self_balancing_bike.ino
float K1 = 24.00;       // P項
float K2 = -20.00;      // I項
float K3 = -9.00;       // D項
float K4 = -0.00;       // 位置項
```

- **K1 (P項)**: 角度偏差に対する比例項（24.00）
- **K2 (I項)**: 角速度に対する積分項（-20.00）
- **K3 (D項)**: モーター速度に対する微分項（-9.00）
- **K4**: 位置項（現在は0で無効）

#### 制御式
```
PWM = K1 × robot_angle + K2 × gyroXfilt + K3 × motor_speed + K4 × motor_pos
```

各項の役割:
1. **K1 × robot_angle**: 角度偏差に対する比例応答
2. **K2 × gyroXfilt**: 角速度フィードバック（ローパスフィルタ適用済み）
3. **K3 × motor_speed**: 速度フィードバック（エンコーダーから取得）
4. **K4 × motor_pos**: 位置フィードバック（現在は無効）

### 2.3 角速度フィルタリング

```146:148:01.Arduino Code and Library/self_balancing_bike.ino
      gyroX = GyX / 131.0; // 度/秒に変換

      gyroXfilt = alpha * gyroX + (1 - alpha) * gyroXfilt;
```

- **ローパスフィルタ**: `alpha = 0.4`の一次IIRフィルタ
- **式**: `gyroXfilt = 0.4 × gyroX + 0.6 × gyroXfilt`
- **目的**: ノイズを低減しつつ、応答性を維持

### 2.4 エンコーダーによる速度測定

#### エンコーダー読み取り関数
```219:239:01.Arduino Code and Library/functions.ino
void ENC_READ() {
  byte cur = (!digitalRead(ENC_1) << 1) + !digitalRead(ENC_2);
  byte old = pos & B00000011;
  byte dir = (pos & B00110000) >> 4;
 
  if (cur == 3) cur = 2;
  else if (cur == 2) cur = 3;
 
  if (cur != old) {
  if (dir == 0) {
    if (cur == 1 || cur == 3) dir = cur;
    } else {
      if (cur == 0) {
        if (dir == 1 && old == 3) enc_count--;
        else if (dir == 3 && old == 1) enc_count++;
        dir = 0;
      }
    }
    pos = (dir << 4) + (old << 2) + cur;
  }
}
```

- **方式**: 2相エンコーダー（A/B相）を使用
- **割り込み**: `CHANGE`で4倍カウントを実現
- **速度計算**: `motor_speed = -enc_count`（10ms周期でリセット）

### 2.5 モーターPWM制御

#### モーター制御関数
```146:150:01.Arduino Code and Library/functions.ino
void Motor1_control(int sp) {
  if (sp > 0) digitalWrite(DIR_1, LOW);
    else digitalWrite(DIR_1, HIGH);
  analogWrite(PWM_1, 255 - abs(sp));
}
```

#### 制御の仕組み
1. **方向制御**: `DIR_1`ピンで正転/逆転を切り替え
   - `sp > 0`: LOW（正転）
   - `sp ≤ 0`: HIGH（逆転）
2. **PWM制御**: `PWM_1`ピンで速度を制御
   - `255 - abs(sp)`: 逆転PWM（0=最大速度、255=停止）
   - 範囲: -255 ～ +255

#### PWM周波数の設定
```81:83:01.Arduino Code and Library/self_balancing_bike.ino
  // ピンD9とD10 - 7.8 kHz
  TCCR1A = 0b00000001;                        // ピン9,10のPWM設定
  TCCR1B = 0b00001010;                        // ピン9,10のPWM設定
```

- **ピン**: D9, D10（Timer1を使用）
- **周波数**: 約7.8kHz（可聴域外のノイズを低減）

### 2.6 制御ループのタイミング

#### メインループ
```132:196:01.Arduino Code and Library/self_balancing_bike.ino
void loop() {

  currentT = millis();

  if (currentT - previousT_1 >= loop_time) {
    readControlParameters();  
    angle_calc();

    motor_speed = -enc_count;
    enc_count = 0;

    if (vertical && calibrated && !calibrating) {
      digitalWrite(BRAKE, HIGH);
      gyroX = GyX / 131.0; // 度/秒に変換

      gyroXfilt = alpha * gyroX + (1 - alpha) * gyroXfilt;

      motor_pos += motor_speed;
      motor_pos = constrain(motor_pos, -110, 110);
      
      int pwm = constrain(K1 * robot_angle + K2 * gyroXfilt + K3 * motor_speed + K4 * motor_pos, -255, 255); 
      Motor1_control(-pwm);
      
      if ((steering_value - STEERING_CENTER - steering_remote) > ST_LIMIT)
        steering_value -= ST_LIMIT;
      else if ((steering_value - STEERING_CENTER - steering_remote) < -ST_LIMIT)
        steering_value += ST_LIMIT;
      else
        steering_value = STEERING_CENTER + steering_remote;

      steering_servo.write(steering_value);
      
      steering_servo2.write(STEERING_CENTER + speed_remote*7);
      
    } else { 
      digitalWrite(BRAKE, LOW);
      steering_value = STEERING_CENTER;
      steering_servo.write(STEERING_CENTER);
      steering_servo2.write(STEERING_CENTER);
      speed_value = 0;
      Motor1_control(0);
      Motor2_control(0);
      motor_pos = 0;
    }
    previousT_1 = currentT;
  }
  
  if (currentT - previousT_2 >= 2000) {    
    battVoltage((double)analogRead(VBAT) / bat_divider); 
    if (!calibrated && !calibrating) {
      Serial.println("first you need to calibrate the balancing point...");
    }
    previousT_2 = currentT;
  }
}
```

#### タイミング設定
- **メイン制御ループ**: 10ms（`loop_time = 10`）
- **バッテリー監視**: 2秒（2000ms）
- **実行順序**:
  1. リモート制御パラメータ読み取り
  2. 角度計算
  3. エンコーダー速度取得
  4. PID制御計算
  5. モーター出力

### 2.7 安全機能とバランス状態の管理

#### 動作条件
```144:185:01.Arduino Code and Library/self_balancing_bike.ino
    if (vertical && calibrated && !calibrating) {
      digitalWrite(BRAKE, HIGH);
      gyroX = GyX / 131.0; // 度/秒に変換

      gyroXfilt = alpha * gyroX + (1 - alpha) * gyroXfilt;

      motor_pos += motor_speed;
      motor_pos = constrain(motor_pos, -110, 110);
      
      int pwm = constrain(K1 * robot_angle + K2 * gyroXfilt + K3 * motor_speed + K4 * motor_pos, -255, 255); 
      Motor1_control(-pwm);
      
      steering_servo.write(steering_value);
      
      steering_servo2.write(STEERING_CENTER + speed_remote*7);
      
    } else { 
      digitalWrite(BRAKE, LOW);
      steering_value = STEERING_CENTER;
      steering_servo.write(STEERING_CENTER);
      steering_servo2.write(STEERING_CENTER);
      speed_value = 0;
      Motor1_control(0);
      Motor2_control(0);
      motor_pos = 0;
    }
```

#### モーター動作の条件
モーターが動作するためには、以下の**3つの条件をすべて満たす必要があります**：

1. **`vertical == true`**: ロボットが垂直状態（±0.3度以内）
2. **`calibrated == true`**: キャリブレーションデータがEEPROMに保存されている
3. **`calibrating == false`**: キャリブレーション中ではない

#### モーター停止の条件
以下の**いずれかの条件**が満たされると、モーターは即座に停止します：

1. **角度が範囲外** (`vertical == false`)
   - `abs(robot_angle) > 10度`: 倒立状態と判定
   - `abs(robot_angle) >= 0.3度`: 垂直範囲外

2. **キャリブレーション未実施** (`calibrated == false`)
   - EEPROMにキャリブレーションデータがない場合

3. **キャリブレーション中** (`calibrating == true`)
   - キャリブレーション処理が実行中の場合

#### 停止時の動作
モーター停止時には以下の処理が実行されます：

```176:185:01.Arduino Code and Library/self_balancing_bike.ino
    } else { 
      digitalWrite(BRAKE, LOW);
      steering_value = STEERING_CENTER;
      steering_servo.write(STEERING_CENTER);
      steering_servo2.write(STEERING_CENTER);
      speed_value = 0;
      Motor1_control(0);
      Motor2_control(0);
      motor_pos = 0;
    }
```

- **ブレーキ**: `BRAKE`ピンをLOW（ブレーキ解除）
- **モーター**: 両モーターを停止（PWM=0）
- **サーボ**: 中立位置（`STEERING_CENTER = 1500`）に戻す
- **位置リセット**: `motor_pos = 0`にリセット

#### 復帰方法

##### 1. 角度による自動復帰
```101:102:01.Arduino Code and Library/functions.ino
  if (abs(robot_angle) > 10) vertical = false;
  if (abs(robot_angle) < 0.3) vertical = true;
```

- **復帰条件**: ロボットの角度が±0.3度以内に戻る
- **復帰方法**: 自動的に`vertical = true`に設定される
- **注意**: `calibrated == true`かつ`calibrating == false`である必要がある

##### 2. キャリブレーション実施後の復帰
- **初回起動時**: EEPROMにキャリブレーションデータがない場合
  - シリアル通信で`c+`コマンドを送信してキャリブレーションモードに入る
  - バイクを垂直に立てた状態で`c-`コマンドを送信してキャリブレーションを保存
  - `calibrated = true`になり、自動的に動作可能になる

##### 3. キャリブレーション完了後の復帰
- **キャリブレーション中**: `calibrating == true`の場合
  - キャリブレーション完了（`save()`関数実行）で`calibrating = false`になる
  - 自動的に動作可能になる

#### 状態遷移図

```
[起動]
  ↓
[EEPROM読み込み]
  ↓
[キャリブレーションデータ確認]
  ├─ あり → calibrated = true
  └─ なし → calibrated = false
  ↓
[MPU6050初期化]
  ↓
[ジャイロオフセット補正（約3秒）]
  ↓
[メインループ開始]
  ↓
[角度計算]
  ↓
[垂直判定]
  ├─ abs(angle) < 0.3度 → vertical = true
  └─ abs(angle) > 10度 → vertical = false
  ↓
[動作条件チェック]
  ├─ vertical && calibrated && !calibrating → [モーター動作]
  └─ それ以外 → [モーター停止]
```

#### 安全機能のまとめ

| 状態 | vertical | calibrated | calibrating | モーター動作 | ブレーキ |
|------|----------|------------|-------------|-------------|---------|
| 正常動作 | true | true | false | ✅ 動作 | HIGH |
| 角度範囲外 | false | true | false | ❌ 停止 | LOW |
| 未キャリブレーション | true | false | false | ❌ 停止 | LOW |
| キャリブレーション中 | true | true | true | ❌ 停止 | LOW |

## 3. 起動時の動作と確認項目

### 3.1 起動シーケンス

#### setup()関数の実行順序
```78:130:01.Arduino Code and Library/self_balancing_bike.ino
void setup() {
  Serial.begin(115200);                       // シリアル通信の初期化

  // ピンD9とD10 - 7.8 kHz
  TCCR1A = 0b00000001;                        // ピン9,10のPWM設定
  TCCR1B = 0b00001010;                        // ピン9,10のPWM設定

  steering_servo.attach(A3);                  // サーボモーターのピン定義
  steering_servo.write(STEERING_CENTER);       // サーボを中立位置に

  steering_servo2.attach(10);                  // サーボモーターのピン定義
  steering_servo2.write(STEERING_CENTER);     // サーボを中立位置に

  pinMode(DIR_1, OUTPUT);                     // 方向1ピンのモード定義
  pinMode(DIR_2, OUTPUT);                     // 方向2ピンのモード定義
  pinMode(BRAKE, OUTPUT);                     // ブレーキピンのモード定義
  pinMode(BUZZER, OUTPUT);                    // ブザーピンのモード定義
  pinMode(ENC_1, INPUT);                      // エンコーダーAピンのモード定義
  pinMode(ENC_2, INPUT);                      // エンコーダーBピンのモード定義
  
  Motor1_control(0);                          // モーター1の速度を0に設定
  Motor2_control(0);                          // モーター2の速度を0に設定

  attachInterrupt(0, ENC_READ, CHANGE);       // 割り込み源0、エンコーダー読み取り関数をトリガー、レベル変化でトリガー
  attachInterrupt(1, ENC_READ, CHANGE);       // 割り込み源1、エンコーダー読み取り関数をトリガー、レベル変化でトリガー

  EEPROM.get(0, offsets);                     // EEPROMからキャリブレーションデータを読み取り
  if (offsets.ID == 35) 
    {
      calibrated = true;                      // データIDが35の場合、calibratedをtrueに（キャリブレーションデータあり）
      Serial.println("Read calibration data!");
    }
  else 
    {
      calibrated = false;                     // 読み取れなかった場合、calibratedをfalseに
      Serial.println("Has no calibration data!");
    }

  EEPROM.get(50, MyPid);                     // EEPROMからPIDデータを読み取り
  if (MyPid.ID == 55)
    {
      PIDHas = true;                          // データIDが55の場合、PIDHasをtrueに（PIDデータあり）
      Serial.println("Read PID data!");
    }
  else
    {
      PIDHas = false;                         // 読み取れなかった場合、PIDHasをfalseに
      Serial.println("Has no PID data!");
    }
  delay(3000);                                // 遅延
  beep();                                     // ブザーで通知
  angle_setup();                              // 角度設定
}
```

### 3.2 起動時の各ステップ

#### ステップ1: シリアル通信の初期化
- **処理**: `Serial.begin(115200)`
- **確認項目**:
  - シリアルモニターが115200bpsで接続されているか
  - シリアル通信が正常に動作しているか

#### ステップ2: PWM周波数の設定
- **処理**: Timer1の設定（D9, D10ピンを7.8kHzに設定）
- **確認項目**:
  - PWM出力が正常に動作しているか（オシロスコープで確認推奨）

#### ステップ3: サーボモーターの初期化
- **処理**: 両サーボを中立位置（1500）に設定
- **確認項目**:
  - サーボが中立位置に移動しているか
  - サーボの動作音が正常か

#### ステップ4: ピンモードの設定
- **処理**: 各ピンの入出力モードを設定
- **確認項目**:
  - モーター制御ピン（DIR_1, DIR_2, PWM_1, PWM_2）がOUTPUTに設定されているか
  - エンコーダーピン（ENC_1, ENC_2）がINPUTに設定されているか
  - ブレーキピン（BRAKE）がOUTPUTに設定されているか

#### ステップ5: モーターの停止
- **処理**: 両モーターを停止状態に設定
- **確認項目**:
  - モーターが停止しているか
  - モーターから異常な音がしないか

#### ステップ6: エンコーダー割り込みの設定
- **処理**: エンコーダーの割り込みを有効化
- **確認項目**:
  - エンコーダーが正常に動作しているか（モーターを手動で回転させて確認）

#### ステップ7: EEPROMからのキャリブレーションデータ読み込み
```104:114:01.Arduino Code and Library/self_balancing_bike.ino
  EEPROM.get(0, offsets);                     // EEPROMからキャリブレーションデータを読み取り
  if (offsets.ID == 35) 
    {
      calibrated = true;                      // データIDが35の場合、calibratedをtrueに（キャリブレーションデータあり）
      Serial.println("Read calibration data!");
    }
  else 
    {
      calibrated = false;                     // 読み取れなかった場合、calibratedをfalseに
      Serial.println("Has no calibration data!");
    }
```

- **処理**: EEPROMアドレス0からキャリブレーションデータを読み込み
- **確認項目**:
  - シリアルモニターに「Read calibration data!」または「Has no calibration data!」が表示されるか
  - `calibrated`フラグが正しく設定されているか

#### ステップ8: EEPROMからのPIDデータ読み込み
```116:126:01.Arduino Code and Library/self_balancing_bike.ino
  EEPROM.get(50, MyPid);                     // EEPROMからPIDデータを読み取り
  if (MyPid.ID == 55)
    {
      PIDHas = true;                          // データIDが55の場合、PIDHasをtrueに（PIDデータあり）
      Serial.println("Read PID data!");
    }
  else
    {
      PIDHas = false;                         // 読み取れなかった場合、PIDHasをfalseに
      Serial.println("Has no PID data!");
    }
```

- **処理**: EEPROMアドレス50からPIDパラメータを読み込み
- **確認項目**:
  - シリアルモニターに「Read PID data!」または「Has no PID data!」が表示されるか
  - `PIDHas`フラグが正しく設定されているか
  - PIDパラメータ（K1, K2, K3, K4）が正しく読み込まれているか

#### ステップ9: 3秒待機
- **処理**: `delay(3000)`
- **目的**: システムの安定化とユーザーへの準備時間の提供
- **確認項目**: 待機中に異常がないか

#### ステップ10: ブザー音の再生（1回目）
- **処理**: `beep()`関数の実行
- **意味**: 起動準備完了の合図
- **タイミング**: EEPROM読み込み完了後、MPU6050初期化の直前
- **確認項目**:
  - ブザーが1回鳴るか（20ms ON、40ms OFF）
  - この時点でシステムは動作準備が整っている

#### ステップ11: MPU6050の初期化とジャイロオフセット補正
```112:130:01.Arduino Code and Library/functions.ino
void angle_setup() {
  Wire.begin();                                   // I2Cマスターとして初期化
  delay(100);                                     // 遅延
  writeTo(MPU6050, PWR_MGMT_1, 0);                // MPU6050電源レジスタの初期化
  writeTo(MPU6050, ACCEL_CONFIG, accSens << 3);   // 加速度計の出力スケールを指定
  writeTo(MPU6050, GYRO_CONFIG, gyroSens << 3);   // ジャイロの出力スケールを指定
  delay(100);                                     // 遅延

  for (int i = 0; i < 1024; i++) {
    angle_calc();
    GyX_offset_sum += GyX;
    delay(3);
  }

  GyX_offset = GyX_offset_sum >> 10;
  beep();
  beep();
  Serial.print("GyX offset: ");  Serial.println(GyX_offset);
}
```

- **処理**:
  1. I2C通信の初期化
  2. MPU6050の電源管理レジスタの設定
  3. 加速度計とジャイロの設定（感度設定）
  4. 1024サンプル（約3秒）でジャイロオフセットを計算
  5. オフセット値をシリアル出力
- **所要時間**: 約3.2秒（1024 × 3ms + 200ms）
- **確認項目**:
  - ブザーが2回鳴るか（補正完了の合図）
  - シリアルモニターに「GyX offset: [値]」が表示されるか
  - オフセット値が適切な範囲内か（通常は-100～+100程度）

#### 起動時のビープ音の意味

起動時には合計**3回**のビープ音が鳴ります：

1. **1回目のビープ音**（ステップ10）
   - **タイミング**: EEPROM読み込み完了後、約3秒待機後
   - **意味**: システムの起動準備が完了したことを示す
   - **状態**: この時点でハードウェアの初期化は完了しているが、MPU6050の補正はまだ未完了

2. **2回目のビープ音**（ステップ11、angle_setup()内）
   - **タイミング**: ジャイロオフセット補正完了直後
   - **意味**: ジャイロオフセット補正が正常に完了したことを示す
   - **状態**: MPU6050の初期化とジャイロオフセット補正が完了

3. **3回目のビープ音**（ステップ11、angle_setup()内）
   - **タイミング**: 2回目のビープ音の直後
   - **意味**: システムが完全に起動完了し、動作可能な状態になったことを示す
   - **状態**: すべての初期化処理が完了し、メインループに移行可能

**注意**: ビープ音が正常に鳴らない場合、以下の可能性があります：
- ブザーが正しく接続されていない
- 電源供給に問題がある
- MPU6050の初期化に失敗している（2回目・3回目のビープ音が鳴らない場合）

### 3.3 起動時の確認チェックリスト

#### ハードウェア確認
- [ ] 電源が正常に供給されているか
- [ ] MPU6050が正しく接続されているか（I2C通信確認）
- [ ] モーターが正しく接続されているか
- [ ] エンコーダーが正しく接続されているか
- [ ] サーボモーターが正しく接続されているか
- [ ] ブザーが動作するか

#### ソフトウェア確認
- [ ] シリアルモニターが115200bpsで接続されているか
- [ ] キャリブレーションデータがEEPROMに保存されているか
- [ ] PIDパラメータがEEPROMに保存されているか
- [ ] MPU6050の初期化が正常に完了するか
- [ ] ジャイロオフセットが正常に計算されるか

#### 動作確認
- [ ] 起動時にモーターが停止しているか
- [ ] サーボが中立位置にあるか
- [ ] ブザーが適切なタイミングで鳴るか
- [ ] シリアル出力が正常に表示されるか

### 3.4 起動時のキャリブレーションについて

#### キャリブレーションの種類

起動時には**2種類のキャリブレーション**が行われます：

##### 1. 自動キャリブレーション（ジャイロオフセット補正）

**処理内容**:
- 起動時に自動的に実行される（`angle_setup()`関数内）
- MPU6050のジャイロセンサーのオフセット値を自動計算
- 1024サンプル（約3秒間）のデータを平均化してオフセットを算出

**処理フロー**:
```112:130:01.Arduino Code and Library/functions.ino
void angle_setup() {
  Wire.begin();                                   // I2Cマスターとして初期化
  delay(100);                                     // 遅延
  writeTo(MPU6050, PWR_MGMT_1, 0);                // MPU6050電源レジスタの初期化
  writeTo(MPU6050, ACCEL_CONFIG, accSens << 3);   // 加速度計の出力スケールを指定
  writeTo(MPU6050, GYRO_CONFIG, gyroSens << 3);   // ジャイロの出力スケールを指定
  delay(100);                                     // 遅延

  for (int i = 0; i < 1024; i++) {
    angle_calc();
    GyX_offset_sum += GyX;
    delay(3);
  }

  GyX_offset = GyX_offset_sum >> 10;
  beep();
  beep();
  Serial.print("GyX offset: ");  Serial.println(GyX_offset);
}
```

**重要なポイント**:
- バイクは**静止状態**で起動する必要がある（動かさない）
- 補正中にバイクを動かすと、誤ったオフセット値が計算される
- 補正完了後、ビープ音が2回鳴る（補正完了の合図）

##### 2. 手動キャリブレーション（加速度計オフセット補正）

**処理内容**:
- 初回起動時のみ必要（EEPROMにデータがない場合）
- 加速度計のオフセット値を手動で設定
- バイクを垂直に立てた状態でのみ実行可能

**初回起動時の状態**:
1. **シリアルモニターに表示されるメッセージ**:
   ```
   Has no calibration data!
   Has no PID data!
   first you need to calibrate the balancing point...
   ```

2. **キャリブレーション手順**:
   - シリアル通信で`c+`コマンドを送信してキャリブレーションモードに入る
     - シリアルモニターに「calibrating on」と表示される
   - **バイクを垂直に立てた状態**で`c-`コマンドを送信
     - この時点での加速度計の値をキャリブレーション値として保存
   - キャリブレーションデータがEEPROMに保存される
     - `offsets.ID = 35`が設定される
     - `offsets.AcY`と`offsets.AcZ`が保存される
   - ビープ音が1回鳴る（保存完了の合図）
   - 次回起動時から自動的に動作可能になる

**キャリブレーションコマンドの実装**:
```195:206:01.Arduino Code and Library/functions.ino
    case 'c':
      if (cmd == '+' && !calibrating) {
        calibrating = true;
        Serial.println("calibrating on");
      }
      if (cmd == '-' && calibrating)  {
          offsets.ID = 35;
          offsets.AcZ = AcZ + 16384;
          offsets.AcY = AcY;
          Serial.print("AcY: "); Serial.print(offsets.AcY); Serial.print(" AcZ: "); Serial.println(offsets.AcZ); 
          save();
      }
      break;
```

**重要なポイント**:
- `c+`コマンドでキャリブレーションモードに入る
- `c-`コマンドで現在の加速度計の値を保存
- バイクは**完全に垂直**（±0.3度以内）の状態で`c-`を実行する必要がある
- キャリブレーション中はモーターは動作しない（安全機能）

#### キャリブレーション未実施の場合

**症状**:
- シリアルモニターに「Has no calibration data!」が表示される
- `calibrated = false`の状態が続く
- モーターが動作しない（動作条件を満たさないため）

**対処方法**:
1. 上記の手動キャリブレーション手順を実行
2. キャリブレーション完了後、次回起動時から自動的に動作可能になる

#### PIDパラメータの調整

**調整方法**:
- シリアル通信で`Tuning()`関数を使用してPIDパラメータを調整
- コマンド形式: `[パラメータ][+/-]`
  - `p+`: K1（P項）を+1
  - `p-`: K1（P項）を-1
  - `i+`: K2（I項）を+0.5
  - `i-`: K2（I項）を-0.5
  - `s+`: K3（D項）を+0.2
  - `s-`: K3（D項）を-0.2
  - `a+`: K4（位置項）を+0.05
  - `a-`: K4（位置項）を-0.05
- 調整後は自動的にEEPROMに保存される（`PidSave()`関数が呼ばれる）
- ビープ音が1回鳴る（保存完了の合図）

#### キャリブレーションのまとめ

| キャリブレーション種類 | 実行タイミング | 実行方法 | 保存先 | ビープ音 |
|---------------------|-------------|---------|--------|---------|
| ジャイロオフセット補正 | 起動時毎回 | 自動 | メモリ（変数） | 2回（補正完了） |
| 加速度計オフセット補正 | 初回のみ | 手動（`c+`/`c-`） | EEPROM | 1回（保存完了） |
| PIDパラメータ | 必要に応じて | 手動（`p+/-`等） | EEPROM | 1回（保存完了） |

### 3.5 起動完了後の動作

起動シーケンス完了後、`loop()`関数が10ms周期で実行されます：

1. **リモート制御パラメータの読み取り**
2. **角度計算**（MPU6050からデータ取得）
3. **エンコーダー速度の取得**
4. **動作条件のチェック**
   - `vertical && calibrated && !calibrating`の場合のみモーター動作
5. **PID制御計算とモーター出力**
6. **バッテリー電圧の監視**（2秒ごと）

## 4. システムの特徴と最適化ポイント

### 4.1 角度計算の特徴
- ✅ 補完フィルタでジャイロと加速度計を統合
- ✅ 初期化時にジャイロオフセットを自動補正
- ✅ EEPROMで加速度計オフセットを保存・復元

### 4.2 モーター制御の特徴
- ✅ 多項PID制御（角度・角速度・速度・位置）
- ✅ エンコーダーによる速度フィードバック
- ✅ 高周波PWM（7.8kHz）で可聴ノイズを低減
- ✅ 10ms制御周期で応答性を確保

### 4.3 改善の余地
1. **K4（位置項）が0**: 位置制御が未使用
2. **積分項の実装**: 現在は角速度のみで、角度の積分項がない
3. **モーター2の制御**: コメントアウトされている（将来の拡張用）

## 5. まとめ

本システムは、MPU6050センサーによる高精度な角度計算と、PID制御によるモーター制御を組み合わせることで、セルフバランシングバイクのバランスを維持しています。補完フィルタによるセンサーフュージョンと、多項PID制御による安定性と応答性の両立が特徴です。10msの制御周期とエンコーダーによる速度フィードバックにより、実用的なバランス制御を実現しています。

